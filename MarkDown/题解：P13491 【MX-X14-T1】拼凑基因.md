## 分析

题意：要求判断能否将字符串 $S$ 分割成若干连续子串，然后通过重新排列这些子串的顺序，使其与字符串 $T$ 完全相同。两个字符串长度均为 $n$，且只包含小写英文字母。

这道题的关键在于：如果 $S$ 能通过分割重组得到 $T$，那么 $S$ 和 $T$ 必须包含完全相同的字符（包括每个字符的数量）。

因为，如果两个字符串包含的字符种类或数量不同，无论如何分割重组都不可能让它们相等，并且，如果两个字符串字符组成完全相同，我们总可以通过适当的分割方式（比如每个字符作为一个子串）来重组得到目标字符串。

因此，我们只需要检查 $S$ 和 $T$ 的字符计数是否完全一致即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt[26] = {0};  // 用于计数每个字母的出现次数
int main() {
    int n;
    string s, t;
    cin >> n >> s >> t;
    // 统计S中每个字符的出现次数
    for (int i = 0; i < n; i++) cnt[s[i] - 'a']++;
    // 减去T中每个字符的出现次数
    for (int i = 0; i < n; i++) cnt[t[i] - 'a']--;
    // 检查所有字符的计数是否都为0
    for (int i = 0; i < 26; i++) {
        if (cnt[i] != 0) {
            cout << "No";
            return 0;
        }
    }
    cout << "Yes";
    return 0;
}
```